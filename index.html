<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Purdue Parking Map</title>

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/esri-leaflet/dist/esri-leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>


    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        h1 {
            text-align: center;
            margin: 10px;
        }
        #map {
            height: 600px;
            width: 100%;
        }
        #controls {
            padding: 10px;
            background: #f4f4f4;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            border-bottom: 1px solid #ccc;
        }
        #controls label {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #controls input, #controls select {
            padding: 4px;
        }
        
      .leaflet-marker-icon.leaflet-zoom-animated {
        max-width: 24px !important;
        max-height: 24px !important;
      }

        #legend {
          position: absolute;
          bottom: 15px;
          right: 15px;
          background: white;
          padding: 10px;
          border-radius: 6px;
          font-size: 14px;
          box-shadow: 0 0 5px rgba(0,0,0,0.3);
          z-index: 1000;
        }
        .legend-item {
          display: inline-block;
          width: 12px;
          height: 12px;
          margin-right: 6px;
          vertical-align: middle;
        }
    </style>
</head>
<body>

<h1>Purdue Parking Finder</h1>

<div id="controls">
    <label>Pass Type: 
        <select id="passType" onchange="filterParking()">
            <option value="">-- Select Pass Type --</option>
        </select>
    </label>

    <label>Destination Building:
      <select id="building" onchange="buildingChanged()">
        <option value="">-- Select Building --</option>
      </select>
    </label>
    
    <label>
      Handicap Parking:
      <input type="checkbox" id="handicapToggle" checked onchange="toggleHandicapParking()">
    </label>
    
    <label>Free Parking Only:
        <input type="checkbox" id="freeOnly" onchange="filterParking()">
    </label>

    <label>Visit Time:
        <input type="time" id="visitTime">
    </label>

    <button onclick="filterParking()">Find Parking</button>
</div>
<div id="noLotsMessage" style="display: none; text-align: center; padding: 10px; color: red; font-weight: bold;">
  No matching parking lots found.
</div>
<div id="map"></div>

<script>
    // Initialize the map at Purdue coordinates
    var map = L.map('map').setView([40.4237, -86.9212], 15);

    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Add a simple traffic layer (free option - demo)
    // This is just an example visualization for traffic
    var trafficLayer = L.tileLayer('https://tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
        attribution: 'Traffic demo tiles',
        opacity: 0.3
    }).addTo(map);

    // Load parking lot data from ArcGIS FeatureServer
    const passTypeSelect = document.getElementById('passType');
    
    // Set to collect unique pass types (LOT_PERM)
    const typeSet = new Set();
    
    // Temporary storage for layers to allow filtering
    let allParkingLayers = [];
    
    // Define the style function using LOT_PERM
    function getLotStyle(lotPerm) {
        let color;
        switch (lotPerm) {
            case 'A':
                color = '#1f77b4'; // blue
                break;
            case 'B':
                color = '#2ca02c'; // green
                break;
            case 'C':
                color = '#ff7f0e'; // orange
                break;
            case 'Paid':
                color = '#d62728'; // red
                break;
            case 'Visitor':
                color = '#9467bd'; // purple
                break;
            default:
                color = '#888888'; // gray
        }
    
        return {
            color: '#000000',
            weight: 1,
            fillColor: color,
            fillOpacity: 0.4
        };
    }
    
    // Add "-- All --" option first
    const allOption = document.createElement('option');
    allOption.value = '';
    allOption.textContent = '-- All --';
    passTypeSelect.appendChild(allOption);
    
    // Load ArcGIS Feature Layer
    L.esri
      .featureLayer({
        url: 'https://services1.arcgis.com/mLNdQKiKsj5Z5YMN/arcgis/rest/services/Parking2020/FeatureServer/0'
      })
      .query()
      .where('1=1')
      .run((error, featureCollection) => {
        if (error) {
          console.error('Error loading parking data:', error);
          return;
        }
    
        // Clear any existing layers
        allParkingLayers = [];
    
        const geojsonLayer = L.geoJSON(featureCollection, {
          style: feature => {
            return getLotStyle(feature.properties.LOT_PERM);
          },
          onEachFeature: function (feature, layer) {
            const props = feature.properties;
    
            const types = props.LOT_PERM
              ? props.LOT_PERM.split(/[,\s]+/).map(t => t.trim()).filter(Boolean)
              : [];
    
            types.forEach(t => typeSet.add(t));
    
            const center = layer.getBounds().getCenter();
            const googleMapsURL = `https://www.google.com/maps/dir/?api=1&destination=${center.lat},${center.lng}`;
    
            layer.bindPopup(`
              <b>${props.LOT_NAME || 'Parking Lot'}</b><br>
              Type: ${types.join(', ')}<br>
              Description: ${props.LotDesc || 'Not Available'}<br>
              <a href="${googleMapsURL}" target="_blank" rel="noopener">Get Directions</a>
            `);
    
            allParkingLayers.push(layer);
          }
        }).addTo(map);
    
        // Populate dropdown after data is loaded
        const sortedTypes = Array.from(typeSet).sort();
    
        const passTypeSelect = document.getElementById('passType');
        passTypeSelect.innerHTML = '';
    
        const allOption = document.createElement('option');
        allOption.value = '';
        allOption.textContent = '-- All --';
        passTypeSelect.appendChild(allOption);
    
        sortedTypes.forEach(type => {
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type;
          passTypeSelect.appendChild(option);
        });
      });


    // Load dummy construction zones
    fetch('data/construction.geojson')
      .then(res => res.json())
      .then(data => {
        // Get today's date (no time) for comparison
        const today = new Date();
        today.setHours(0, 0, 0, 0);
    
        // Filter features where endDate is in the future or today
        const filteredFeatures = data.features.filter(feature => {
          const endDateStr = feature.properties.endDate;
          if (!endDateStr) return true; // if no endDate, show by default
          const endDate = new Date(endDateStr);
          return endDate >= today;
        });
    
        // Create a new GeoJSON object with filtered features
        const filteredData = {
          type: "FeatureCollection",
          features: filteredFeatures
        };
    
        L.geoJSON(filteredData, {
          style: {
            color: 'red',    
            weight: 3,
            dashArray: '5,5',   
            fillOpacity: 0.2
          },
          onEachFeature: (feature, layer) => {
            const p = feature.properties;
            layer.bindPopup(`<b>Construction:</b> ${p.name}<br>Expected until: ${p.endDate}`);
          }
        }).addTo(map);
      });


    let buildingLayer = null;
    let selectedBuildingLayer = null;
    
    const buildingSelect = document.getElementById('building');
    
    // Load ArcGIS Feature Layer
    let selectedBuildingAbbr = null; // Track selected building globally
    
    let buildingFeatures = []; // ← Declare this outside so it's accessible
    
    buildingLayer = L.esri.featureLayer({
      url: 'https://services1.arcgis.com/mLNdQKiKsj5Z5YMN/arcgis/rest/services/Export_Output106/FeatureServer/0',
      style: function(feature) {
        const abbr = feature.properties.BLDG_ABBR;
        const isSelected = abbr === selectedBuildingAbbr;
    
        return {
          color: isSelected ? '#0000ff' : '#666',
          weight: isSelected ? 2 : 0.5,
          opacity: isSelected ? 1 : 0.6
        };
      },
      onEachFeature: function (feature, layer) {
        buildingFeatures.push(feature); // collect for dropdown
      }
    }).addTo(map);

    let handicapLayer = null;
    // Load handicap parking KML layer
    handicapLayer = omnivore.kml('https://purdueuniversity.maps.arcgis.com/sharing/rest/content/items/13158cca51cf4190aaa002bde42f816d/data')
      .on('ready', function() {
        this.eachLayer(function(layer) {
          if (layer instanceof L.Marker) {
            layer.setIcon(handicapIcon);
            layer.bindPopup('Handicap Accessible Parking');
          }
        });
      })
      .addTo(map);
    
    // Wait until all features are loaded before populating the select
    buildingLayer.on('load', function() {
      const sorted = buildingFeatures
        .filter(f => f.properties.BLDG_ABBR && f.properties.BUILDING_N)
        .sort((a, b) => {
          const abbrA = a.properties.BLDG_ABBR.toUpperCase();
          const abbrB = b.properties.BLDG_ABBR.toUpperCase();
          return abbrA.localeCompare(abbrB);
        });
    
      sorted.forEach(feature => {
        const abbr = feature.properties.BLDG_ABBR;
        const name = feature.properties.BUILDING_N;
        const option = document.createElement('option');
        option.value = abbr;
        option.textContent = `(${abbr}) ${name}`;
        buildingSelect.appendChild(option);
      });
    });

    function getDistance(latlng1, latlng2) {
      return map.distance(latlng1, latlng2); // returns meters
    }
    
    // Filtering function
    function filterParking() {
      const selectedType = document.getElementById('passType').value;
      const freeOnly = document.getElementById('freeOnly')?.checked;
      const selectedAbbr = document.getElementById('building').value;
    
      let visibleCount = 0;
      let buildingCenter = null;
    
      if (selectedAbbr && buildingLayer) {
        buildingLayer.eachFeature(layer => {
          const props = layer.feature?.properties;
          if (props?.BLDG_ABBR === selectedAbbr) {
            buildingCenter = layer.getBounds().getCenter();
          }
        });
      }
    
      const visibleLayers = [];
    
      allParkingLayers.forEach(layer => {
        const props = layer.feature?.properties;
        const types = props?.LOT_PERM
          ? props.LOT_PERM.split(/[,\s]+/).map(s => s.trim()).filter(Boolean)
          : [];
    
        let visible = true;
    
        if (freeOnly && !props?.FREE) {
          visible = false;
        }
    
        if (selectedType && !types.some(t => t.startsWith(selectedType))) {
          visible = false;
        }
    
        if (visible) {
          visibleLayers.push(layer);
        } else {
          map.removeLayer(layer);
        }
      });
    
      // Sort by distance if building selected
      if (buildingCenter) {
        visibleLayers.sort((a, b) => {
          const aCenter = a.getBounds().getCenter();
          const bCenter = b.getBounds().getCenter();
          return getDistance(buildingCenter, aCenter) - getDistance(buildingCenter, bCenter);
        });
      }
    
      // Re-add sorted layers
      visibleLayers.forEach(layer => {
        map.addLayer(layer);
        visibleCount++;
      });
    
      document.getElementById('noLotsMessage').style.display = visibleCount === 0 ? 'block' : 'none';
    }



    
    function buildingChanged() {
      const selectedAbbr = document.getElementById('building').value;
    
      if (!buildingLayer) return;
    
      selectedBuildingAbbr = selectedAbbr || null; // update global
    
      if (!selectedAbbr) {
        map.setView([40.4237, -86.9212], 15);
      } else {
        buildingLayer.eachFeature(layer => {
          const props = layer.feature?.properties;
          if (props?.BLDG_ABBR === selectedAbbr) {
            const bounds = layer.getBounds();
            const padding = window.innerWidth > 768 ? [200, 200] : [100, 100];
            map.fitBounds(bounds, { padding });
          }
        });
      }
    
      buildingLayer.setStyle(buildingLayer.options.style); // reapply style
      filterParking();
    }

    const handicapIcon = L.icon({
      iconUrl: 'https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/svgs/solid/wheelchair.svg',
      iconSize: [20, 20],
      iconAnchor: [10, 20],
      popupAnchor: [0, -20]
    });

    function toggleHandicapParking() {
      const show = document.getElementById('handicapToggle').checked;
      if (handicapLayer) {
        if (show) {
          map.addLayer(handicapLayer);
        } else {
          map.removeLayer(handicapLayer);
        }
      }
    }

</script>
<div id="legend">
  <strong>Legend:</strong><br>
  <span class="legend-item" style="background-color:#1f77b4"></span> A<br>
  <span class="legend-item" style="background-color:#2ca02c"></span> B<br>
  <span class="legend-item" style="background-color:#ff7f0e"></span> C<br>
  <span class="legend-item" style="background-color:#d62728"></span> Paid<br>
  <span class="legend-item" style="background-color:#9467bd"></span> Visitor<br>
  <span class="legend-item" style="background-color:#888888"></span> Other
</div>
</body>
</html>
