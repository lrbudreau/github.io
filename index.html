<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Purdue Parking Map</title>

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/esri-leaflet/dist/esri-leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>

    <!-- Turf.js for geometry merging -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        h1 {
            text-align: center;
            margin: 10px;
        }
        #map {
            height: 600px;
            width: 100%;
        }
        #controls {
            padding: 10px;
            background: #f4f4f4;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            border-bottom: 1px solid #ccc;
        }
        #controls label {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #controls input, #controls select {
            padding: 4px;
        }
        .leaflet-marker-icon.leaflet-zoom-animated {
            max-width: 24px !important;
            max-height: 24px !important;
        }
        .info.legend {
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            line-height: 1.5;
            max-width: 250px;
            border: 1px solid #ccc;
        }
        .legend-entry {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }
        .legend-item {
            width: 14px;
            height: 14px;
            display: inline-block;
            margin-right: 6px;
            border: 1px solid #000;
        }   
        #building {
            max-width: 100%;
            width: 100%;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
        }
        #noLotsMessage {
            display: none;
            text-align: center;
            padding: 10px;
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>

<h1>Purdue Parking Finder</h1>
<div id="controls">
    <label>Pass Type: 
        <select id="passType" onchange="filterParking()">
            <option value="">-- Select Pass Type --</option>
        </select>
    </label>

    <label>Destination Building:
        <select id="building" onchange="buildingChanged()">
            <option value="">-- Select Building --</option>
        </select>
    </label>
    
    <label>
        Handicap Parking:
        <input type="checkbox" id="handicapToggle" checked onchange="toggleHandicapParking()">
    </label>
    
    <label>Free Parking Only:
        <input type="checkbox" id="freeOnly" onchange="filterParking()">
    </label>

    <label>Visit Time:
        <input type="time" id="visitTime">
    </label>

    <button onclick="filterParking()">Find Parking</button>
</div>
<div id="noLotsMessage">No matching lots found.</div>
<div id="map"></div>

<script>
  // Initialize the map at Purdue coordinates
  var map = L.map('map').setView([40.4237, -86.9212], 15);

  // Add OpenStreetMap tiles
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map);

  // Add legend control to the map
  const legendControl = L.control({ position: 'bottomleft' });

  legendControl.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'info legend');
    div.id = 'legend';
    return div;
  };

  legendControl.addTo(map);

  // Only ONE reference to the legend DOM element â€” after it's added to the map
  const legendDiv = document.getElementById('legend');

  // Add simple traffic layer (demo)
  var trafficLayer = L.tileLayer('https://tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
      attribution: 'Traffic demo tiles',
      opacity: 0.3
  }).addTo(map);

  const passTypeSelect = document.getElementById('passType');
  const noLotsMessage = document.getElementById('noLotsMessage');

  // Set to collect unique pass types (LOT_PERM)
  const typeSet = new Set();

  // Temporary storage for all parking layers for filtering
  let allParkingLayers = [];

  // Dynamic color palette generator for unique LOT_PERM values
  const colorPalette = {};
  const generateColor = (function() {
    const colors = [
      "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
      "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
      "#aec7e8", "#ffbb78", "#98df8a", "#ff9896", "#c5b0d5",
      "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5"
    ];
    let index = 0;
    return function(type) {
      if (!colorPalette[type]) {
        colorPalette[type] = colors[index % colors.length];
        index++;
      }
      return colorPalette[type];
    }
  })();

  function getLotStyle(lotPerm) {
    const types = lotPerm ? lotPerm.split(/[,\s]+/).map(t => t.trim()).filter(Boolean) : [];
    const mainType = types.length > 0 ? types[0] : 'Other';
    const color = generateColor(mainType) || '#888888';
    return {
      color: '#000000',
      weight: 1,
      fillColor: color,
      fillOpacity: 0.4
    };
  }

  function updateLegend() {
    legendDiv.innerHTML = '<strong>Legend:</strong><br>';

    const sortedTypes = Array.from(typeSet).sort((a,b) => {
      if (a === 'Other') return 1;
      if (b === 'Other') return -1;
      return a.localeCompare(b);
    });

    sortedTypes.forEach(type => {
      const color = generateColor(type);

      const item = document.createElement('div');
      item.className = 'legend-entry';

      const span = document.createElement('span');
      span.className = 'legend-item';
      span.style.backgroundColor = color;

      const label = document.createElement('span');
      label.textContent = ` ${type}`;

      item.appendChild(span);
      item.appendChild(label);
      legendDiv.appendChild(item);
    });
  }

  noLotsMessage.style.display = 'none';

  // -------------- REPLACED PARKING DATA LOADING (MERGED LAYERS) --------------
  fetch('https://services1.arcgis.com/mLNdQKiKsj5Z5YMN/arcgis/rest/services/Parking2020/FeatureServer/0/query?where=1=1&outFields=*&f=geojson')
    .then(res => res.json())
    .then(featureCollection => {
      allParkingLayers = [];
      typeSet.clear();

      // Group features by LOT_NAME
      const grouped = {};

      featureCollection.features.forEach(feature => {
        const lotName = feature.properties.LOT_NAME || 'Unknown';

        if (!grouped[lotName]) {
          grouped[lotName] = {
            properties: feature.properties,
            geometries: []
          };
        }

        grouped[lotName].geometries.push(feature.geometry);
      });

      const mergedFeatures = [];

      for (const lotName in grouped) {
        const group = grouped[lotName];
        const { geometries, properties } = group;

        let mergedGeometry = geometries[0];
        for (let i = 1; i < geometries.length; i++) {
          try {
            mergedGeometry = turf.union(
              turf.feature(mergedGeometry),
              turf.feature(geometries[i])
            ).geometry;
          } catch (err) {
            console.warn(`Could not merge geometry for ${lotName}`, err);
          }
        }

        mergedFeatures.push({
          type: 'Feature',
          properties: properties,
          geometry: mergedGeometry
        });
      }

      const geojsonLayer = L.geoJSON(mergedFeatures, {
        style: feature => getLotStyle(feature.properties.LOT_PERM),
        onEachFeature: (feature, layer) => {
          const props = feature.properties;

          const types = props.LOT_PERM
            ? props.LOT_PERM.split(/[,\s]+/).map(t => t.trim()).filter(Boolean)
            : ['Other'];

          types.forEach(t => typeSet.add(t));

          const center = layer.getBounds().getCenter();
          const googleMapsURL = `https://www.google.com/maps/dir/?api=1&destination=${center.lat},${center.lng}`;

          layer.bindPopup(`
            <b>${props.LOT_NAME || 'Parking Lot'}</b><br>
            Type: ${types.join(', ')}<br>
            Description: ${props.LotDesc || 'Not Available'}<br>
            <a href="${googleMapsURL}" target="_blank" rel="noopener">Get Directions</a>
          `);

          allParkingLayers.push(layer);
        }
      }).addTo(map);

      // Populate pass type dropdown
      const sortedTypes = Array.from(typeSet).sort();
      passTypeSelect.innerHTML = '';
      const allOption = document.createElement('option');
      allOption.value = '';
      allOption.textContent = '-- All --';
      passTypeSelect.appendChild(allOption);

      sortedTypes.forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type;
        passTypeSelect.appendChild(option);
      });

      updateLegend();
      filterParking();
    })
    .catch(err => {
      console.error('Error loading or processing parking data:', err);
    });


  // Placeholder functions for filtering and building change (you can fill these in)
  function filterParking() {
    // Example filter function: show/hide parking layers based on pass type and other filters
    const selectedType = passTypeSelect.value;
    const freeOnly = document.getElementById('freeOnly').checked;
    const handicapOnly = document.getElementById('handicapToggle').checked;

    let visibleCount = 0;

    allParkingLayers.forEach(layer => {
      const props = layer.feature.properties;
      const lotTypes = props.LOT_PERM ? props.LOT_PERM.split(/[,\s]+/).map(t => t.trim()) : [];

      let matchesType = !selectedType || lotTypes.includes(selectedType);
      let matchesFree = !freeOnly || (props.FREE === 'Yes' || props.FREE === 'YES');
      let matchesHandicap = handicapOnly ? (props.HANDICAP === 'Yes' || props.HANDICAP === 'YES') : true;

      if (matchesType && matchesFree && matchesHandicap) {
        layer.addTo(map);
        visibleCount++;
      } else {
        map.removeLayer(layer);
      }
    });

    noLotsMessage.style.display = visibleCount === 0 ? 'block' : 'none';
  }

  function buildingChanged() {
    // You can implement logic for when the building dropdown changes
    // Example: Zoom to building location or update available parking options
  }

  function toggleHandicapParking() {
    filterParking();
  }
</script>

</body>
</html>
