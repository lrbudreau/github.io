<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Purdue Parking Map</title> <!-- Leaflet CSS & JS --> <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" /> <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script> <script src="https://unpkg.com/esri-leaflet/dist/esri-leaflet.js"></script> <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script> <style> body { font-family: Arial, sans-serif; margin: 0; padding: 0; } h1 { text-align: center; margin: 10px; } #map { height: 600px; width: 100%; } #controls { padding: 10px; background: #f4f4f4; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; border-bottom: 1px solid #ccc; } #controls label { display: flex; align-items: center; gap: 5px; } #controls input, #controls select { padding: 4px; } .leaflet-marker-icon.leaflet-zoom-animated { max-width: 24px !important; max-height: 24px !important; } .info.legend { background: white; padding: 10px; border-radius: 5px; box-shadow: 0 0 6px rgba(0, 0, 0, 0.2); font-size: 14px; line-height: 1.5; max-width: 250px; border: 1px solid #ccc; } .legend-entry { display: flex; align-items: center; margin: 4px 0; } .legend-item { width: 14px; height: 14px; display: inline-block; margin-right: 6px; border: 1px solid #000; } #building { max-width: 100%; width: 100%; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; } </style> </head> <body> <h1>Purdue Parking Finder</h1> <div id="controls"> <label>Pass Type: <select id="passType" onchange="filterParking()"> <option value="">-- Select Pass Type --</option> </select> </label> <label>Destination Building: <select id="building" onchange="buildingChanged()"> <option value="">-- Select Building --</option> </select> </label> <label> Handicap Parking: <input type="checkbox" id="handicapToggle" checked onchange="toggleHandicapParking()"> </label> <label>Free Parking Only: <input type="checkbox" id="freeOnly" onchange="filterParking()"> </label> <label>Visit Time: <input type="time" id="visitTime"> </label> <button onclick="filterParking()">Find Parking</button> </div> <div id="noLotsMessage">No matching lots found.</div> <div id="map"></div> <script> // Initialize the map at Purdue coordinates var map = L.map('map').setView([40.4237, -86.9212], 15); // Add OpenStreetMap tiles L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }).addTo(map); // Add legend control to the map const legendControl = L.control({ position: 'bottomleft' }); legendControl.onAdd = function(map) { const div = L.DomUtil.create('div', 'info legend'); div.id = 'legend'; return div; }; legendControl.addTo(map); // Only ONE reference to the legend DOM element — after it's added to the map const legendDiv = document.getElementById('legend'); // Add simple traffic layer (demo) var trafficLayer = L.tileLayer('https://tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', { attribution: 'Traffic demo tiles', opacity: 0.3 }).addTo(map); const passTypeSelect = document.getElementById('passType'); const noLotsMessage = document.getElementById('noLotsMessage'); // Set to collect unique pass types (LOT_PERM) const typeSet = new Set(); // Temporary storage for all parking layers for filtering let allParkingLayers = []; // Dynamic color palette generator for unique LOT_PERM values // Returns consistent colors for each type const colorPalette = {}; const generateColor = (function() { const colors = [ "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf", "#aec7e8", "#ffbb78", "#98df8a", "#ff9896", "#c5b0d5", "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5" ]; let index = 0; return function(type) { if (!colorPalette[type]) { colorPalette[type] = colors[index % colors.length]; index++; } return colorPalette[type]; } })(); function getLotStyle(lotPerm) { // Support multiple types separated by comma or space, pick first for color const types = lotPerm ? lotPerm.split(/[,\s]+/).map(t => t.trim()).filter(Boolean) : []; const mainType = types.length > 0 ? types[0] : 'Other'; const color = generateColor(mainType) || '#888888'; return { color: '#000000', weight: 1, fillColor: color, fillOpacity: 0.4 }; } // Populate legend dynamically function updateLegend() { legendDiv.innerHTML = '<strong>Legend:</strong><br>'; const sortedTypes = Array.from(typeSet).sort((a,b) => { if (a === 'Other') return 1; if (b === 'Other') return -1; return a.localeCompare(b); }); sortedTypes.forEach(type => { const color = generateColor(type); const item = document.createElement('div'); item.className = 'legend-entry'; const span = document.createElement('span'); span.className = 'legend-item'; span.style.backgroundColor = color; const label = document.createElement('span'); label.textContent = ${type}; item.appendChild(span); item.appendChild(label); legendDiv.appendChild(item); }); } // Initialize "No matching lots" message style noLotsMessage.style.display = 'none'; // Load parking lot data from ArcGIS FeatureServer L.esri .featureLayer({ url: 'https://services1.arcgis.com/mLNdQKiKsj5Z5YMN/arcgis/rest/services/Parking2020/FeatureServer/0' }) .query() .run((error, featureCollection) => { if (error) { console.error('Error loading parking data:', error); return; } allParkingLayers = []; typeSet.clear(); const geojsonLayer = L.geoJSON(featureCollection, { style: feature => getLotStyle(feature.properties.LOT_PERM), onEachFeature: (feature, layer) => { const props = feature.properties; // Add LOT_PERM types to set (split in case multiple) const types = props.LOT_PERM ? props.LOT_PERM.split(/[,\s]+/).map(t => t.trim()).filter(Boolean) : ['Other']; types.forEach(t => typeSet.add(t)); const center = layer.getBounds().getCenter(); const googleMapsURL = https://www.google.com/maps/dir/?api=1&destination=${center.lat},${center.lng}; layer.bindPopup( <b>${props.LOT_NAME || 'Parking Lot'}</b><br> Type: ${types.join(', ')}<br> Description: ${props.LotDesc || 'Not Available'}<br> <a href="${googleMapsURL}" target="_blank" rel="noopener">Get Directions</a> ); allParkingLayers.push(layer); } }).addTo(map); // Populate dropdown after data is loaded const sortedTypes = Array.from(typeSet).sort(); passTypeSelect.innerHTML = ''; const allOption = document.createElement('option'); allOption.value = ''; allOption.textContent = '-- All --'; passTypeSelect.appendChild(allOption); sortedTypes.forEach(type => { const option = document.createElement('option'); option.value = type; option.textContent = type; passTypeSelect.appendChild(option); }); updateLegend(); filterParking(); }); // Construction zones loading (unchanged) fetch('data/construction.geojson') .then(res => res.json()) .then(data => { const today = new Date(); today.setHours(0, 0, 0, 0); const filteredFeatures = data.features.filter(feature => { const endDateStr = feature.properties.endDate; if (!endDateStr) return true; const endDate = new Date(endDateStr); return endDate >= today; }); const filteredData = { type: "FeatureCollection", features: filteredFeatures }; L.geoJSON(filteredData, { style: { color: 'red', weight: 3, dashArray: '5,5', fillOpacity: 0.2 }, onEachFeature: (feature, layer) => { const p = feature.properties; layer.bindPopup(<b>Construction:</b> ${p.name}<br>Expected until: ${p.endDate}); } }).addTo(map); }); // Buildings layer and controls (unchanged except sorting moved here) let buildingLayer = null; let selectedBuildingAbbr = null; let buildingFeatures = []; const buildingSelect = document.getElementById('building'); buildingLayer = L.esri.featureLayer({ url: 'https://services1.arcgis.com/mLNdQKiKsj5Z5YMN/arcgis/rest/services/Export_Output106/FeatureServer/0', style: feature => { const abbr = feature.properties.BLDG_ABBR; const isSelected = abbr === selectedBuildingAbbr; return { color: isSelected ? '#0000ff' : '#666', weight: isSelected ? 2 : 0.5, opacity: isSelected ? 1 : 0.6 }; }, onEachFeature: (feature, layer) => { buildingFeatures.push(feature); } }).addTo(map); buildingLayer.on('load', () => { // Clear previous options buildingSelect.innerHTML = ''; const sorted = buildingFeatures .filter(f => f.properties.BLDG_ABBR && f.properties.BUILDING_N) .sort((a, b) => { const abbrA = a.properties.BLDG_ABBR.toUpperCase(); const abbrB = b.properties.BLDG_ABBR.toUpperCase(); return abbrA.localeCompare(abbrB); }); // Add default option const defaultOpt = document.createElement('option'); defaultOpt.value = ''; defaultOpt.textContent = '-- Select Building --'; buildingSelect.appendChild(defaultOpt); const maxLength = 35; sorted.forEach(feature => { const abbr = feature.properties.BLDG_ABBR; const name = feature.properties.BUILDING_N; const option = document.createElement('option'); option.value = abbr; const displayName = (${abbr}) ${name}; option.title = displayName; option.textContent = displayName.length > maxLength ? displayName.slice(0, maxLength) + '…' : displayName; buildingSelect.appendChild(option); }); }); function getDistance(latlng1, latlng2) { return map.distance(latlng1, latlng2); } // Filtering function function filterParking() { const selectedType = passTypeSelect.value; const freeOnly = document.getElementById('freeOnly')?.checked; const selectedAbbr = buildingSelect.value; let visibleCount = 0; let buildingCenter = null; if (selectedAbbr && buildingLayer) { buildingLayer.eachFeature(layer => { const props = layer.feature?.properties; if (props?.BLDG_ABBR === selectedAbbr) { buildingCenter = layer.getBounds().getCenter(); } }); } let visibleLayers = []; allParkingLayers.forEach(layer => { const props = layer.feature?.properties; const types = props?.LOT_PERM ? props.LOT_PERM.split(/[,\s]+/).map(s => s.trim()).filter(Boolean) : ['Other']; let visible = true; if (freeOnly && !props?.FREE) { visible = false; } if (selectedType && !types.includes(selectedType)) { visible = false; } if (visible) { visibleLayers.push(layer); } else { map.removeLayer(layer); } }); // Sort visible layers by distance if building selected if (buildingCenter) { visibleLayers.sort((a, b) => { const aCenter = a.getBounds().getCenter(); const bCenter = b.getBounds().getCenter(); return getDistance(buildingCenter, aCenter) - getDistance(buildingCenter, bCenter); }); } // Re-add sorted layers visibleLayers.forEach(layer => { map.addLayer(layer); visibleCount++; }); noLotsMessage.style.display = visibleCount === 0 ? 'block' : 'none'; } function buildingChanged() { const selectedAbbr = buildingSelect.value; if (!buildingLayer) return; selectedBuildingAbbr = selectedAbbr || null; if (!selectedAbbr) { map.setView([40.4237, -86.9212], 15); } else { buildingLayer.eachFeature(layer => { const props = layer.feature?.properties; if (props?.BLDG_ABBR === selectedAbbr) { const bounds = layer.getBounds(); const padding = window.innerWidth > 768 ? [200, 200] : [100, 100]; map.fitBounds(bounds, { padding }); } }); } buildingLayer.setStyle(buildingLayer.options.style); filterParking(); } // Handicap parking icon & layer (unchanged) const handicapIcon = L.icon({ iconUrl: 'https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/svgs/solid/wheelchair.svg', iconSize: [20, 20], iconAnchor: [10, 20], popupAnchor: [0, -20] }); let handicapLayer = null; handicapLayer = omnivore.kml('https://purdueuniversity.maps.arcgis.com/sharing/rest/content/items/13158cca51cf4190aaa002bde42f816d/data') .on('ready', function() { this.eachLayer(function(layer) { if (layer instanceof L.Marker) { layer.setIcon(handicapIcon); layer.bindPopup('Handicap Accessible Parking'); } }); }) .addTo(map); function toggleHandicapParking() { const show = document.getElementById('handicapToggle').checked; if (handicapLayer) { if (show) { map.addLayer(handicapLayer); } else { map.removeLayer(handicapLayer); } } } // Event listeners to trigger filtering passTypeSelect.addEventListener('change', filterParking); document.getElementById('freeOnly')?.addEventListener('change', filterParking); buildingSelect.addEventListener('change', buildingChanged); </script> </body> </html>
